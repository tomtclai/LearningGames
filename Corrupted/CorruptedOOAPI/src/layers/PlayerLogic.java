package layers;

import structures.IntVector;
import corrupted.Game;
import corrupted.ErrorHandler;
import gridElements.*;
import gridElements.GridElement.ColorEnum;

public class PlayerLogic extends LogicBase
{
	//this grid needs to be maintained here because we currently want to hide the fact that the player
	//is in a grid. originally we wanted to have the player in a grid to teach arrays. perhaps we no longer
	//need a grid for the player.
	GridElement[][] grid;
	/**
	 * initializes a PlayerLogic class with methods that help control the player object.
	 * @author Brian Chau
	 * @param layM Game for communication with other layers
	 * @param geGrid 2D grid containing player space
	 */
	public PlayerLogic(Game layM, GridElement[][] geGrid)
	{
		super(layM);
		grid = geGrid;
		IntVector playerPosition = new IntVector(0, mGM.getHeight()/2);
		Player player = new Player(playerPosition, GridElement.getRandomColorEnum(), mGM);
		putElement(playerPosition,player);
	}
	
	/**
	 * gets the playerGrid from the Game
	 * @return the grid that this Logic class executes on.
	 */
	@Override
	protected GridElement[][] getTheGrid()
	{

		verifyInitializedGrid();
		return grid;
	}
	
	/**
	 * sets the player's height position to pos.
	 * If pos is greater or equal to the game's set height, it is set to height-1.
	 * if pos is less than 0, it is set to 0.
	 * 
	 * @author Brian Chau
	 * @param pos height position to set the player
	 */
	public void setPlayerHeight(int pos)
	{
		if (pos > mGM.getHeight()-1) pos = mGM.getHeight()-1;
		if (pos < 0) pos = 0;
		IntVector source = getPlayerPosition();
		if(source.getY() != pos){
			this.moveElement(false, source, new IntVector(0,pos));
		}
	}

	/**
	 * moves the player down one
	 * @author Brian Chau
	 */
	public void movePlayerDown()
	{
		verifyInitializedGrid();
		//scan in opposite direction of movement, this prevents infinite movement of the player
		for (int y = 1; y < mGM.getHeight(); y++)
		{
			if (grid[0][y] != null)
			{
				moveElement(false, new IntVector(0,y), new IntVector(0,y-1));
			}
		}
	}
	
	/**
	 * moves the player up one
	 * @author Brian Chau
	 */
	public void movePlayerUp()
	{
		verifyInitializedGrid();
		//scan in opposite direction of movement, this prevents infinite movement of the player
		for (int y = mGM.getHeight()-2; y >= 0; y--)
		{
			if (grid[0][y] != null)
			{
				moveElement(false, new IntVector(0,y), new IntVector(0,y+1));
				return; //if we dont return here, will loop and continue to move he player right again since we have moved it into the next cell in the loop
			}
		}
	}
	
	/**
	 * shootTile uses the player to generate a tile to give to the Game 
	 * to pass to the TileLayer. The player will then have a random color 
	 * assigned as its next tile to shoot
	 * @author Brian Chau
	 * @return the tile generated by the player
	 */
	public Tile generatePlayerTile()
	{
		//find the first player and get the Tile
		Player player = getPlayer();
		if (player != null)
		{
			return player.generateTile();
		}
		return null; //return null if there are no players
	}
	
	/**
	 * Force to change the color of player.
	 * 
	 * @param col color to change the player
	 */
	public void setPlayerColorEnum(ColorEnum col)
	{
		//find the first player and get the Tile
		Player player = getPlayer();
		if (player != null)
		{
			player.setColorEnum(col);;
		}	
	}
	
	/**
	 * gets the player's location
	 * @author Brian Chau
	 * @return a player object. null if empty
	 */
	private Player getPlayer()
	{
		verifyInitializedGrid();
		try{
			for (int y = 0; y < mGM.getHeight(); y++)
			{
				//find the first player and get the Tile
				//currently the playergrid is not exposed in the Game API. there should only be one player
				//but for now we are keeping this grid based, but it is possible to do this without a grid
				if (grid[0][y] != null)
				{
					return (Player)grid[0][y];
				}
			}
		}
		catch(ArrayIndexOutOfBoundsException e)
		{
			ErrorHandler.printErrorAndQuit(ErrorHandler.OUT_OF_BOUNDS);
		}
		return null;
	}
	
	/**
	 * Gets the player's position as an IntVector.
	 * @return The player's position. Null if no player exists (we should never allow this).
	 */
	public IntVector getPlayerPosition()
	{
		try{
			for (int y = 0; y < mGM.getHeight(); y++)
			{
				//find the first player and return the IntVector representing the position
				//currently the playergrid is not exposed in the Game API. there should only be one player
				//but for now we are keeping this grid based, but it is possible to do this without a grid
				if (grid[0][y] != null)
				{
					return new IntVector(0,y);
				}
			}
		}
		catch(ArrayIndexOutOfBoundsException e)
		{
			ErrorHandler.printErrorAndQuit(ErrorHandler.OUT_OF_BOUNDS);
		}
		return null;
	}
	
	/**
	 * gets the current color of the player
	 * @return the color of the player
	 */
	public ColorEnum getPlayerColor()
	{
		return getPlayer().getColorEnum();
	}
	
	/**
	 * Sets the targeting laser mode (this affects drawing only).
	 * InfiniteLaserMode true: laser will draw to the end of the screen if there is a clear path.
	 * InfiniteLaserMode false: laser will stop on the last column that has tiles on it
	 * @param mode if true, InfiniteLasermode will be on.
	 */
	public void setPlayerInfiniteLaserDrawing(boolean mode)
	{
		getPlayer().setInfiniteLaserMode(mode);
	}
	
	/**
	 * Sets the visibility of the player cannon. Some games may not want to use the cannon functionality. 
	 * @param visible if true, the player will be drawn. If false, the player will be invisible
	 */
	public void setPlayerVisibility(boolean visible)
	{
		getPlayer().setVisibilityTo(visible);
	}
	
	/**
	 * ensures that the Game tilegrid is initialized.
	 * if not, it initializes it with the default grid
	 */
	private void verifyInitializedGrid()
	{
		if (grid == null)
		{
			mGM.setTileGrid(null);
		}
	}
}
